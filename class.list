Note1: check validation of input values only for user-facing functions

Note2: errors should be trapped and re-thrown with a user-friendly description

detector.py:	
	class Detector:
		def __init__(self, x, y, z):
		def location(self):
			> set, retrieve, validate a location
			> invalid x, y,and/or z
		def vtk(self):
			> verify detector display
		
isotope.py:		
	class Isotope:
		def __init__(self, name):
			> valid name
			> invalid name ('Doxygen')
			> mixed case name
			> non-alpha name
		def photons(self):
			> validate proper retrieval of photons
		def name(self):
			> set, retrieve, validate name
		def half_life(self):
			> validate half_life
		def key_progeny(self):
			> validate after retrieval
			> validate None
		def _convert_half_life(value, units):
			> verify conversion from a range of input units

material.py:
	class Material:
		def __init__(self, name):
			> valid name
			> invalid name ('Doxygen')
			> mixed case name
			> non-alpha name
		def name(self):
			> set, retrieve, validate name
		def get_mfp(self, energy, distance):
			> validate correct mfp calculation
			> test negative distance
			> test zero distance
			> test negative energy
			> test OOB low energy
			> test OOB high energy
			> test non-numeric energy
			> test non-numeric distance
		def get_mass_atten_coeff(self, energy):
			> verify correct calculation
			> test negative energy
			> test OOB low energy
			> test OOB high energy
		def get_mass_energy_abs_coeff(self, energy):
			> verify correct calculation
			> test negative energy
			> test OOB low energy
			> test OOB high energy
		def get_buildup_factor(self, energy, mfps, formula="GP"):
			> validate proper math
			> test bad formula
			> test lowercase formula
			> test negative energy
			> test OOB low energy
			> test OOB high energy
			> negative mfps
			> single mfp
			> non-numeric mfps
		def _GP(a, b, c, d, X, mfp):
			> validation implicit in get_buildup_factor()

model.py:
	class Model:
		def __init__(self):
		def set_filler_material(self, filler_material, density=None):
			> invalid filler_material
			> negative density
			> non-numeric density
		def add_source(self, new_source):
			> set and verify source addition
		def add_shield(self, new_shield):
			> set and verify shield addition
		def add_detector(self, new_detector):
			> set and verify detector
			> set and verify detector replacement
		def set_buildup_factor_material(self, new_material):
			> set and retrieve buildup factor material
			> invalid filler_material
		def calculate_exposure(self):
			> validate an exposure calculation
			> missing source
			> missing detector
			> missing shield
		def generate_summary(self):
			> validate a summary calculation
		def display(self):
			> validate graphic display

ray.py:
	class FiniteLengthRay:
		def __init__(self, start, end):
			> validate set and retrieval of start and end
			> non-numeric start
			> non-numeric end
		def start(self):
			> validate setting start
			> non-numeric start
		def start(self, value):
			> validate set and retrieval of start
		def end(self):
			> validate setting start
			> non-numeric start
		def end(self, value):
			> validate set and retrieval of end
		def _regularize(self):
			> validate origin, length, dir, and sign

shield.py:
	class Shield:
		def __init__(self, material_name=None, density=None, **kwargs):
		def is_infinite(self):
		def _get_crossing_length(self, ray):
		def get_crossing_mfp(self, ray, photon_energy):
		def _line_plane_collision(plane_normal, plane_point, ray_origin,
                              ray_normal, epsilon=1e-6):
	class SemiInfiniteXSlab(Shield):
		def __init__(self, material_name, x_start, x_end, density=None):
		def is_infinite(self):
		def _get_crossing_length(self, ray):
		def get_crossing_mfp(self, ray, photon_energy):
		def vtk(self):
	class Sphere(Shield):
		#     def __init__(self, material_name, sphere_center, sphere_radius, density=None):
		#     def get_crossing_mfp(self, ray, photon_energy):
		#     def _get_crossing_length(self, ray):
		#     def contains(self, point):
	class Box(Shield):
		def __init__(self, material_name, box_center, box_dimensions,
		def is_infinite(self):
		def get_crossing_mfp(self, ray, photon_energy):
		def _get_crossing_length(self, ray):
		def _contains(self, point):
		def _intersect_axis_aligned_box(self, ray):
		def vtk(self):
	class InfiniteAnnulus(Shield):
		def __init__(self, material_name, cylinder_origin, cylinder_axis,
		def is_infinite(self):
		def get_crossing_mfp(self, ray, photon_energy):
		def _get_crossing_length(self, ray):
		def _contains(self, point):
		def _intersect(self, ray):
		def vtk(self):
	class YAlignedInfiniteAnnulus(InfiniteAnnulus):
		def __init__(self, material_name, cylinder_center, cylinder_inner_radius,
	class XAlignedInfiniteAnnulus(InfiniteAnnulus):
		def __init__(self, material_name, cylinder_center, cylinder_inner_radius,
	class ZAlignedInfiniteAnnulus(InfiniteAnnulus):
		def __init__(self, material_name, cylinder_center, cylinder_inner_radius,
	class CappedCylinder(Shield):
		def __init__(self, material_name, cylinder_start, cylinder_end,
		def is_infinite(self):
		def get_crossing_mfp(self, ray, photon_energy):
		def _get_crossing_length(self, ray):
		def _contains(self, point):
		def _intersect(self, ray):
		def vtk(self):
	class YAlignedCylinder(CappedCylinder):
		def __init__(self, material_name, cylinder_center, cylinder_length,
	class XAlignedCylinder(CappedCylinder):
		def __init__(self, material_name, cylinder_center, cylinder_length,
	class ZAlignedCylinder(CappedCylinder):
		def __init__(self, material_name, cylinder_center, cylinder_length,

source.py:
	class GroupOption(Enum):
		GROUP = "group"
		HYBRID = "hybrid"
		DISCRETE = "discrete"
	class Source(metaclass=abc.ABCMeta):
		def __init__(self, **kwargs):
		def grouping(self):
		def grouping(self, value):
		def include_key_progeny(self):
			> validate after retrieval
			> validate None
			> test non-logical value
		def include_key_progeny(self, value):
		def add_isotope_curies(self, new_isotope, curies):
		def add_isotope_bq(self, new_isotope, becquerels):
		def add_photon(self, energy, intensity):
		def list_isotopes(self):
		def list_discrete_photons(self):
		# def _get_distributed_source_list(self):
		def get_photon_source_list(self):
	class LineSource(Source, shield.Shield):
		def __init__(self, start, end, **kwargs):
		def _get_source_point_weights(self):
		def _get_source_points(self):
		def _get_crossing_length(self, ray):
		def get_crossing_mfp(self, ray, photon_energy):
		def vtk(self):
	class PointSource(Source, shield.Shield):
		def __init__(self, x, y, z, **kwargs):
		def _get_source_point_weights(self):
		def _get_source_points(self):
		def _get_crossing_length(self, ray):
		def get_crossing_mfp(self, ray, photon_energy):
		def vtk(self):
	class SphereSource(Source, shield.Sphere):
		#     def __init__(self, **kwargs):
		#    def _get_source_point_weights(self):
		#     def _get_source_points(self):
	class BoxSource(Source, shield.Box):
		def __init__(self, **kwargs):
		def _get_source_point_weights(self):
		def _get_source_points(self):
	class ZAlignedCylinderSource(Source, shield.ZAlignedCylinder):
	    def __init__(self, **kwargs):
		def _get_source_point_weights(self):
		def _get_source_points(self):
	class YAlignedCylinderSource(Source, shield.YAlignedCylinder):
		def __init__(self, **kwargs):
		def _get_source_point_weights(self):
		def _get_source_points(self):
	class XAlignedCylinderSource(Source, shield.YAlignedCylinder):
		def __init__(self, **kwargs):
		def _get_source_point_weights(self):
		def _get_source_points(self):
